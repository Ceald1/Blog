+++
title = "Malware101"
date = "2025-11-14T18:20:01-07:00"
author = ""
authorTwitter = "" #do not include @
cover = ""
tags = ["new", "notes", "cybersecurity", "malware", "rust"]
keywords = ["malware","notes", "rust", "windows"]
description = ""
showFullContent = false
readingTime = true
hideComments = false
+++
# Summary
My notes while learning malware development for Windows.


# Malware types

## Notes:
* Sophisticated malware will be able to detect tools trying to analyze it by checking processes running or if it's in a virtual machine.

## RAT
* persistent connection to a machine to monitor things like key strokes.

## Infostealers
* targets sensitive information like medical records or banking information

## Droppers and loaders
* Deploy additional malware through a web request.

## Ransomware
* Denies access to a person's computer for a ransom.

## Wipers
* Destroys sensitive information or entire systems.

## Worms
* Self spreading malware.

## Viruses
* Adds malicious code onto a host system's files.

## Rootkits and Bootkits
* Malware that conceals itself in the kernel or in the BIOS. Rootkits run at system startup while Bootkits start at boot time.

## Trojans
* Pretends to be legit programs to infect a system.





# Windows 101
## Concepts/Essentials

### User mode vs Kernel mode
![](/malware101/kernel_user_mode.png)

### Windows API/WinAPI
* various functions for programs to interact with to function

### Drivers
* Provide an abstraction layer between the actual kernel and user (kernel level anti cheats are drivers)
* Drivers can be ran in user mode or Kernel mode
* Kernel mode have FULL access to the kernel 
* User mode drivers are restricted

### Hardware abstraction Layer
* Interface for hardware to interact with the rest of the system.

### Kernel
* Kernel is the "magic" of this system by having the utilities for everything to communicate and run (somewhat) effectively by handling memory management and other complex tasks.

### Processes and Threads
* Processes are applications
* Threads are instructions for that process (processes can have more than one thread)

### Objects and Handles
* Objects are resources like resources (files, tokens, another process, or thread)
* Handles are identifiers for those processes or objects a program is trying to access
![](/malware101/handles_objects.png)
* Mutexe (Mutual exclusions) control access to objects to prevent system crashes or other issues.


### Windows API
* WinAPI is a library of various functions
* API helps with things from security authentication to even showing a message box
* Docs are notoriously bad

#### Windows Native API
* a lower level windows API
* undocumented by MS
http://undocumented.ntinternals.net/
https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm
![](/malware101/api.png)



#### API Functions:
<!-- (https://wsummerhill.github.io/redteam/2024/02/06/Malware-Development-Introduction-Part1.html) -->

##### Notes
* API functions have various suffixes.
	* `Ex` means newer
	* `A` outputs and inputs in ANSI format (https://ansi.tools/)
	* `W` outputs and inputs in unicode format (https://gist.github.com/jpassaro/bf400b0410810a071a7fb3509ef6c2c3)
* Native API functions have prefixes.  https://stackoverflow.com/questions/4770553/windows-native-api-when-and-why-use-zw-vs-nt-prefixed-api-calls#4770583
	* `Zw` are for kernel mode drivers
	* `Nt` are for user mode applications
* DLLs are libraries that contain these functions
	* kernel32.dll
		* Contains fundamental user mode functions
	* user32.dll
		* For gui applications
	* Winhttp.dll
		* For internet functions for windows programs
	* ntdll.dll
		* Synchronization, threading and other system tasks that communicate with the kernel
	* kernelbase.dll
		* For backwards compatibility for windows apps


<!-- 
##### VirtualAlloc
used for allocating memory in windows for low level API operations


##### RtlMoveMemory/memcpy(C/C++)
copy memory from one source to another


##### VirtualProtect
change memory protections


##### CreateThreat/WaitForSingleObject
Create new thread in the current process. `WaitForSingleObject` called after `CreateThreat` to delay execution until a previous thread is completed. -->


### Process Internals
Processes point to additional data structures. It provides additional information for windows to understand and manage processes

#### EPROCESS Structure
![](/malware101/eprocess.png)
* This is how windows processes are understood by the kernel.
* EPROCESS structures:
	* PEB (process environment block)
		* contains essential information for the process
	* Forward Links (Flink)
		* chains to the Blink
	* Backward Links (Blink)
		* links backwards to the Flink
	* Links just link processes


#### PEB Structure Offsets and Data

| Offset (x86) | Offset (x64) | Data                                                                                                            |
| ------------ | ------------ | --------------------------------------------------------------------------------------------------------------- |
| 0x002        | 0x002        | Stores the BeingDebugged value, which indicates whether the process is running under the context of a debugger. |
| 0x008        | 0x10         | Stores the base address of the process executable in memory.                                                    |
| 0x00C        | 0x18         | Stores information on the modules and libraries the process has loaded.                                         |
| 0x018        | 0x30         | Stores information about the process’s memory heap.                                                             |
| 0x064        | 0xB8         | Stores the NumberOfProcessors value, which indicates the number of processors the system has.                   |


#### TEB (Thread Environment Block aka TIB Thread Information Block)
* Contains Information for process's running threads


| Offset (x86) | Offset (x64) | Data                                                         |
| ------------ | ------------ | ------------------------------------------------------------ |
| FS:[0x00]    | GS:[0x00]    | Stores the current structured exception handler (SEH) frame. |
| FS:[0x04]    | GS:[0x08]    | Points to the base of the thread’s stack.                    |
| FS:[0x18]    | GS:[0x30]    | Points to the TEB itself.                                    |
| FS:[0x20]    | GS:[0x40]    | Stores the process ID (PID) of the thread’s owning process.  |
| FS:[0x24]    | GS:[0x48]    | Stores the thread ID (TID) of the current thread.            |
| FS:[0x30]    | GS:[0x60]    | Points to the PEB of the thread’s owning process.            |
| FS:[0xE10]   | GS:[0x1480]  | Points to thread-local storage (TLS) information.            |

#### Stacks and Heaps
* Stack is where temporary data is stored (destroyed after a thread is done)
* Heap is a large region used to dynamically store memory at runtime (global variables, etc.)

#### Virtual Memory
* In windows processes have virtual memory allocated to them that are mapped to the RAM
* Solves process interference or programs crashing
![](/malware101/pager.png)
* If a process has too little RAM for a process it'll page/store it on disk (like a Linux swapfile or partition)

#### PE Files
* Essentially the windows version of `elf` files
* Contain headers and sections
	* Headers are metadata
	* DOS Headers are for older versions of windows
	* PE header contains information used by the Windows PE Loader
	* Section header contains metadata related to file sections (size, address, etc.)
	* Common sections in table bellow
	
| Section | Description                                                                                                |
| ------- | ---------------------------------------------------------------------------------------------------------- |
| .text   | The file’s main executable code                                                                            |
| .rdata  | Read-only data, such as static variables and constants                                                     |
| .bss    | Uninitialized data, such as variables that haven’t been assigned a value yet                               |
| .data   | Variables not embedded in the .rdata and .bss sections, such as global variables                           |
| .rsrc   | Assets that will be loaded by the executable at runtime, such as images, fonts, and other supporting files |
| .idata  | The imports address table<br>* information about imports used by the PE file                               |
| .edata  | The exports address table<br>* information about exports used by the PE file                               |


#### PE Loading Process
1. Windows makes a new EPROCESS structure
2. Windows allocates virtual memory to the process
3. PE Loader reads and parses the DOS, PE, and optional headers
4. PE Parses all the other headers
5. Loads libraries associated with the PE (`.idata` and or `.rdata`)
6. New thread is created inside the process (`.text` section)
![](/malware101/pe.png)


### Address Space Layout Randomization (ASLR)
* prevents memory corruption


### Registry
* A database that applications and the OS reads and stores configurations

#### Hives
1. HKEY_LOCAL_MACHINE (HKLM)
	* Low level OS
	* Hardware configurations
	* Security Policies
	* Account settings
	* Settings for software installed
	* SAM database
	* LSA Secrets
2. HKEY_CURRENT_USER (HKCU)
	* user and system configurations
3. HKEY_USERS (HKU)
	* User settings
	* Stores the information for every user on the system
	* Sub keys represent identifiers of every user
4. HKEY_CURRENT_CONFIG (HKCC)
	* Pounters to the `HKLM` key for hardware profiles
5. HKEY_CLASSES_ROOT (HKCR)
	* registered application information like default apps to open files



# Evasion techniques

## Process Injection
* Injecting code into another process
* Mimics normal behavior like injecting into a web browser to communicate with a C2 server
* prevents debugging
* privilege escalation, certain processes can elevate privileges
* intercepting data from a hook, this allows for modifying API calls or getting sensitive data.

### Random vs Target Process
* Depending on injecting into a specific process or a random one is goals.
* Targeting specific processes can help with evasion while random ones can trip defenses
* Self-injecting is injecting into its own process, typically during unpacking.

### Shellcode Injection
![](/malware101/shellcode_injection.jpg)
* shellcode injection happens by injecting shell code into a process.
1. call [`OpenProcess`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)/[`NtOpenProcess`](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess) to open a process and specify the proper options
2. After getting the object handle run either [`VirtualAlloc`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), [`VirtualAllocEx`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex), or [`NtAllocateVirtualMemory`](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory) to allocate enough memory for your shellcode.
3. Write the memory to the process with [`WriteProcessMemory`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory) or [`NtWriteVirtualMemory`](https://ntdoc.m417z.com/ntwritevirtualmemory)
4. Call [`CreateRemoteThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread), [`NtCreateThreadEx`](https://ntdoc.m417z.com/ntcreatethreadex) or [`RtlCreateUserThread`](https://ntdoc.m417z.com/rtlcreateuserthread) and input the proper options.

### DLL Injection
![](/malware101/dll_injection.png)
* Common form of process injection by using libraries to inject code once it's loaded
1. add malicious DLL to disk
2. call [`OpenProcess`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)/[`NtOpenProcess`](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess) to open a process and specify the proper options
3. After getting the object handle run either [`VirtualAlloc`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), [`VirtualAllocEx`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex), or [`NtAllocateVirtualMemory`](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory) to allocate enough memory.
4. [`WriteProcessMemory`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory) or [`NtWriteVirtualMemory`](https://ntdoc.m417z.com/ntwritevirtualmemory) to write the location of the DLL.
5. Call [`CreateRemoteThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread), [`NtCreateThreadEx`](https://ntdoc.m417z.com/ntcreatethreadex) or [`RtlCreateUserThread`](https://ntdoc.m417z.com/rtlcreateuserthread) and input the proper options to get the process to read the DLL with `LoadLibrary`.

### Reflective DLL Injection
![](/malware101/reflective_dll.jpg)
* DLLs are injected through being stored in memory instead of  on the disk
* Write the DLL to the memory and transfer the control flow into the new injected DLL.
* [example](https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/manage/reflective_dll_inject.rb)


### Process Hollowing/RunPE
![](/malware101/process_hallowing.jpg)
* Un-maps code from a target's process memory
* Doesn't use an arbitrary remote process, starts a new process instead.
1. Create a new process with `CreateProcess` ([`CreateProcessA`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) or [`CreateProcessW`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw)) with the flag [`CREATE_SUSPENDED`](https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags) or `0x00000004`
2. Unmap the process's code with [`NtUnmapViewOfSection`](https://ntdoc.m417z.com/ntunmapviewofsection)
3. Allocate memory for the new region with [`VirtualAlloc`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
4. write the payload with [`WriteProcessMemory`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)
5. use [`SetThreadContext`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext) and [`ResumeThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread) to point the thread to the new injected code and to resume thread execution.

### Thread Hijacking
* Opening a new thread within a target process to run code.
* Similar to Process Hollowing
1. call [`OpenThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthread) and specify the thread ID to open
2. call [`SuspendThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) or [`Wow64SuspendThread`](https://learn.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-wow64suspendthread) to suspend the thread.
3. use [`VirtualAlloc`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) to allocate memory
4. Write the new memory with [`WriteProcessMemory`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)
5. call [`SetThreadContext`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext) and [`ResumeThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread) to set control flow and resume the thread to run the new code.

### APC Injection/Asynchronous procedure call
![](/malware101/apc_injection.jpg)
* Allows for tasks to be queued and executed in the context of a thread.
1. Write code to the target process normally
2. Open a thread with [`OpenThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthread)
3. Then Queue a new APC task with [`QueueUserAPC`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) or [`NtQueueApcThread`](https://ntdoc.m417z.com/ntqueueapcthread)
4. Resume the process normally to then execute the new APC thread.

### Atom Bombing
![](/malware101/atom.jpg)
* Shares similarities to APC injection but involves "Atoms" (functions and definitions related are in the #Terms 101 section)
1. Create a new global Atom with [`GlobalAddAtom`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaladdatoma)(there are other functions than this one)
2. Start the APC queue with [`NtQueueApcThread`](https://ntdoc.m417z.com/ntqueueapcthread) to force the process to do step 3.
3. get the Atom with [`GlobalGetAtomName`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalgetatomnamea)(there are other functions than this one)
4. Process now is storing the shellcode or malicious code.

-------------------


## Process image manipulation
* tampering process images and windows handles for processes


# Terms 101

* Shellcode: code that executes regardless of where it is in memory (https://medium.com/@yua.mikanana19/position-independent-code-pic-and-shellcode-an-introduction-1ea71f707ad)

* Malware analysis: analyze malware behavior and signatures to identify the threat actor(s).

* EDR(endpoint detection and response): A stack of software for protecting endpoints like domain controllers or critical infrastructure.

* XDR(extended detection and response): A stack of software like an EDR but offers more detection, data sources, and security tools.
* DKOM: Direct kernel object modification
* DCOM: Distributed component object model extends COM objects for remote procedure calls and references
* COM: component object model is for allowing applications to share and distribute data regardless of programming language
* Atoms: specific pieces of data like strings, stored in a structure called an "Atom Table", used in communication between processes to coordinate actions.
* Atom Table: A table of Atoms that can be global ([`GlobalAddAtom`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaladdatoma), there are other functions than this one) or local ([`AddAtom`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-addatoma), there are other functions than this one). 
